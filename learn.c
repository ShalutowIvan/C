/* ранее были только механиеские вычислительные машины на основе двоичного кода
ада лавлейс первый программист. Она написала первые команды для вычислений на ручной механической машине
была еще машина тьюринга для вычислений, уже электрическая
Потом Джон Фон Нейман предложил хранить команды и данные в единой однородной памяти компьютера, а раньше данные и команды записывали в один тип памяти, а данные в другую. Это было прорывным событием, и сейчас до сих пор вся вычислительная техника работает по архитектуре Джона Фон Неймана.
Первое поколение компов использовали этот принцип на электронных лампах для однородности памяти данных и команд. Вычислительная техника получили название машина Фон Неймана.
Второе поколение компов уже было выполнено на транзисторах. ТО есть просто много транзисторов
Третье поколение было уже на основе интегральных схем, это объединение большого колва транзисторов. Компы стали занимать еще меньше места в помещении.
Четвертое поколение компов это уже появление микропроцессора. То есть очень много маленьких схем, в которых очень маленькие транзисторы, это моя догадка. Компы уже стали доступны массовому пользователю. И сейчас все компы можно отнести в 4 поколению, что-то принципиально нового в компах на данный момент не появилось.
архитектура компа:
процессор взаимодействует с другими частями компа через шину которая присоединяется к контроллерам по отдельности на каждое подсоединенное устройство, другие части компа ОЗУ, монитор, клавиатура, HDD, все присоединяется с помощью контроллеров по отдельному контроллеру для каждого устройства. Это сделано так, потому в процессоре нет инфы как считыывать инфу с других подсоединенных к нему устройств. Процессор может только выдавать определенные данные и считывать их из шины. В шину ЦП передает разную инфу: данные адреса, команды управления. Шина делится на 3 составляющие: шина данных, шина адресов, шина управления. И потом с помощью контроллеров ЦП может взаимодействовать с ними на универсальном уровне. Чтобы процессор знал какие команды подавать существуют специальные программы - драйверы, с помощью процессор знает какие команды подавать на то или иное устройство.
Память.
Память это последовательность упорядоченных ячеек. Каждая ячейка имеет свой физический номер, то есть адрес. А сама ячейка представляет собой 8 бит информации. 1 бит кодируется двумя состояними, 0 и 1. То есть одна ячейка памяти это набор из нулей и единиц. 0 это бит выключен, 1 бит включен. 1 ячейка может кодировать 256 различных вариантов, от нуля до 255, 2**8. Каждая ячейка памяти это 1 байт, в котором можно хранить число от 0 до 255.
ЦП заносит в любую ячейку памяти то или иное значение. Либо осуществляет запрос из любой ячейки памяти.
В такой памяти можно хранить комадны для ЦП и данные. Команды и данные кодируются числами от 0 до 255.
Выполнение команд.
Предположим что в ОЗУ хранится набор числа в 16ричной системе счисления (СС), начнем отсчет с ячейки с номером 1000
Процессор оснащен 32 разрядным процессором архитектуры х86.
Чтобы на вход команды поступило первое число с номером в памяти 1000, счетчик команд в ЦП должен быть равен 1000.
В процессоре есть специальные хранилища данных, которые называются регистрами. В них хранится специальная инфа для обработки текущей инфы. Доступ к регистрам происходит очень быстро. Быстрее чем обращение к оперативной памяти. Один регистров процессора это счетчик команд, program counter: xxxx. Его еще называют указателем инструкций.
В счетчике команд  находится инфа о ячейке памяти, то есть в ячейке есть какая-то цифра и она является адресом памяти. Потом в это число записывается инфа со следующей ячейкой памяти. И так далее для каждой команды. Команду могут быть как цифрами так и знаками сложения и вычитания и тд.
Выглядит команда так: команда movl[адрес памяти],%eax. Это команда на ассемблере. То есть процессор должен переместить по адресу памяти в скобках в спец регистр с названием eax, это один из регистров процессора, потом считываются следующие 4 байта. Каждое перемещение это такт процессора. 1ГГЦ это 1 млрд команд в секунду. Размер порций данных называют машинным словом. Обычно размер машинного слова совпадает с разрядностью процессора. Для 32-разрядного процессора машинное слово 32 бита. Процессор обрабатывает только числовые данные. Например все буквы сохарняются в таблице аскикодов. Изобрадения это набор отдельных точек, пикселей, цвет которых определяется числовым значением. Все данные чтобы перенести на пк, их нужно перенести в набор чисел, то есть оцифровать. А все устройства, принтеры, колонки, они преобразуют инфу в исходный привычный для нас вид, то есть звуки картинки и тд.
Теперь чтобы нам просто написать код, нужно написать сначала структуру взаимодействия между процессором клавиатурой монитром мышью, ЖД и память и всеми остальными устройствами. ЧТобы этого не делать для есть операционная система, в ней установлены все нужны драйверы для всех устройств, и система иногда сама ставит драйверы, но не для всех устройств. Для других устройств клавы, мышки и тд используются драйверы.
Запросы со стороны пользователя называются системными вызовами. Через них происходит взаимодействие со всеми устройставми.система через вызовы также выделяет память под нужные данные. ОС нужна для корректного выполнения ПО на компе и взимодействия с ресурсами вычислительной техники. Например в датацентрах есть много компов без клавы и дисплея. Можно установить взаимодействие через сеть ethernet и через командную строку выполнить нужные действия. В 60-х годах появились первые ОС, они не имели пользовательского интерфеса, и все взаимодействие было на уровне команд. Потом начали появляться графические интерфейсы для пользователей. До середины 90-х они не были массовым явлением среди людей. Пока в 95-м году не вышла ОС windows 95. Она стала очень популярна. Эта ОС популярна и до сих пор, и конечно она уже обновлялась много раз.
Есть и другие типы ОС, такие как unix. К ним относят разные вариации linux: debian, ubuntu, fedora, centos. Есть ОС DBS она не относится linux, это другая ОС. И есть еще MacOS. Графический интерфейс в unix реализован не на уровне ядра системы как в windows, а как пользовательская программа, интерфейс которой можно изменить если нужна другая графиская оболочка. Также открытый код unix позволяет создать свои вариации ОС. Из-за этого появилась первая версия ОС adnroid. Появление unix способствовало появлению первой версии языка C.
Некто кен томпсон делал ОС multics. Разработка была неудачная. Но потом эту ОС улучшили. Назвали ее unix. Потом сделали ОС для компа pdp7. Это очень старый комп. Потом кен томпсон совместно с денисом ритчи решили перенести ее на машину pdp11. Для этого нужно было переписать ОС. ЧТобы не писать на ассемблере Кен томпсон решил использовать язык B, это усеченная версия языка bcpl. Он был очень не удобным для создания ОС. Решили усовершенствовать язык B и назвали его C, это просто след буква алфавита. В 1972 году появилась первая версия языка C. Автором считается денис ритчи. На этом языке C кон томпсон написал ОС unix для пк pdp11. Язык С был создан чтобы уйти от языка ассемблера на более высокий уровень, но при этом сохранить все приемущества языка ассемблер, предоставляя программисту полный контроль и полную свободу действий. То есть С самый низкоуровневый из всех высокоуровневых языков. На нем пишут беспилотники, искуственный интеллект и тд.

Последовательносить команд, которые подаются на центральный процессор, называется машинным кодом. В ассемблере дается удобство для создания программ. То есть машинные кода заменены словами. Идет команда то есть действие которое нужно сделать с содержимым регистров или памяти, в ассемблере используются мнемоники для каждой числовой команды и регистров процессора. То есть например, movl адрес памяти, регистр процессора, переместили кусок памяти в другой регистр процессора. Можно писать эти мнемоники и компилятор языка ассемблер будет переводить в процессор эти мнемоники в виде машинного кода. Вообще компилятор это такая программа, которая переводит текст программы в машинный код.
Но набор команд на ассемблере на каждом процессоре может быть разный, и на каждом компе нужно будет писать разные команды на ассемблере.
Это очень сложно. Потом денис ритчи создал язык С. У языка С есть компилятор, с помощью качественно идет перевод в машинный код. Результат компиляции будет такой как будто программа написана на языке ассемблер и работает на любом компе. Скорость выполнения программ будет максимально высокой. Без изоишеств будет использоваться ресурс компа. Это используется во многих направлениях:
- игровой индустрии при разработке движков
- дополненной реальности
- обучение нейронных сетей
- создание надежных программ управления оборудованием в реальном режиме времени.
Такой подход будет до тех пор, пока программы пишет человек в привычном на данный момент способом.
Трансляция в машинный код:
модули: файл 1, файл 2, файл 3.
все файлы каждый модуль пропускается через текстовый препроцессор. Он ищет все директивы в файлах, то есть указания для препроцессора и выполнить их. В итоге текст программы становится другим, но логика программы сохраняется. потом текст программы передается на компилятор, и проходят через лексический анализатор. Выделяются возможные синтаксические ошибки. Если ошибок нет, то потом программа переводится в машинный код. Вы выходе получаются объектные файлы для каждого модуля-файла. В этих объектых файлах получается просто машинный код, в них нет связей между модулями, нет реализации библиотечных функций и код запуска всей программы.
Все связи на конечном этапе делает Линкер (редактор связей). Он объединяет все модули в один файл, добавляет код запуска для конкретной операционной системы, и добавляет реализацию библиотечных функций. И на выходе получается итоговый исполняемый файл. Почему так, это вопрос к разработчикам языка С.
В чем плюсы:
- В такой структуре, каждый файл модуль компилируется отдельно в машинный код, это позволяет сократить время компиляции. Первый раз нужно будет сформировать объектные файлы для каждого модуля. При последующих компиляциях, будут перекомпилированы только измененные модули. Это экономит время при изменении и отладки проекта.
- Также линкер добавляет реализации только тех библиотечных функций, которые используются в программе. Ничего лишнего на выходе не образуется.
- Использование компилятора позволяет переносить программы с одной ОС на другую без потерь. Или с одной архитектуры процессора на другую. И так как компилятор языка С реализованы на всех ОС, то программы на языке С самые переносимые среди языков высокого уровня.
Также компиляторы языка С пишутся разными людьми, и работают с некоторыми отличиями. Но программисту не нужно задумываться о реализации разных компиляторов, и все компиляторы одинаково транслируются в машинный код. Добиться этого стандартизацией. ТО есть нужно договориться о синтаксисе и наборе команд в языке С.
Первым неформальным стандартом стала книга Брайана Кернигана и Дениса Ритчи, книга называется "Язык программирования С". Но далее по всему миру стали использщовать этот язык, и понадобилось создание официального стандарта для языка С, который бы включал все полезные новшества этого языка. С этой целью в 1983 году национальный институт стандартизации США, сокращенно ANSI(American National standart institute) образовал специальную рабочую группу комитетс названием X3J11.
А в 1989 году появился стандарт ANSI C или C89. Но принят был только в 1990 году. Поэтому его еще называют С90.
Комитет X3J11 сформилировал несколько важных принципов:
-доверять программисту - то есть компилятор должен доверять программисту, то есть тому коду что он написал в программе.
-не мешать программисту делать то, что он считает необходимым - то есть не накладывать дополнительные не нужные ограничения.
-без необходимости не усложнять язык, сохраняя его простоту - то есть не добавлять в него лишних конструкций.
-каждая операция должна иметь только один способ выполнения
-операция должна выполняться максимально быстро,даже в ущерб переносимости языка.
В 1994 году появилась необходимость создания нового стандарта, так как популярность его росла, и он применялся в самых разных задачах.
В 1999 появился новый стандарт под названием С99.
Нужны были следующие аспекты:
-интернационализация(поддержка нескольких международных языков) на программном уровне.
-устранение некоторых неточностей предыдущей версии языка стандарта ANSI C.
-повышение стабильности математических вычислений для возможности безопасного использования языка в научных проектах.
Также С стал хорошей базой для языка программиования С++, автором языка С++ является Бьерн страуструп, сотрудник фирмы BelLaboratories. В языке С++ появилась ООП, шаблоны классов и функций и други полезные инструменты для разработки программ любого уровня сложности. А новые стандарты языка С относятся к языку С++. В 2011 году был принят стандарт известный как С11, но деятельность комитетов стандартизации на это не закончилась. 2014, 2017, 2020... Этот процесс будет продолжаться пока есть язык С и С++.
*/
// запуск exe файла
// чтобы запустить exe файл нужно .\название файла
// установка visual studio code и его настройка
// установить компилятор с можно с сайта: https://gcc.gnu.org/
// там нужно выбрать сбоку в разделе download Binaries, потом скачать компилятор minGW
// ставим. потом нужно выбрать пакеты. При отметке нужных нам пакетов будут отмечаться и другие пакеты автоматом
// список компонентов:
// minGW32-gcc-bin  - это основной компонент для С
// minGW32-gcc-g++-bin - отсюда берется линкер
// minGW32-make-bin
// minGW32-gdb-bin - это для дебагинга
// потом жмем installation, apply changes, aply
// потом в переменных среды нужно прописать путь к компилятору в системной переменной path

// ctrl + ~ это вызов терминала
// если компилировать через командную строку, то будет создаваться файл exe, но можно сделать так чтобы в vscode работала компиляция автоматом
// установили расширение c/c++ intellisense
// установили расширение code runner
// ctrl + alt + n это запуск С кода с
// теперь нужно настроить компилятор под стандарт С99
// gcc -std=c99 - outputfilesourcefile.c
// -std=c99 это нужно прописать для компилятора gcc в json файле tasks в папке .vscode в строке "args": после квадратных скобок
// и потом нужно нажать file preferences, setting, в поиске набрать code runner run in terminal и поставить галочки в code runner in terminal. И появится json файл settings с кодом     "code-runner.runInTerminal": true
// потом в поиске пишем run code configuration и ищем code runner executor map и нажимаем edit in settings json. Там нужно найти строку с языком С и прописать стандарт -std=c99 после "c": "cd $dir && gcc. Также в строке "code-runner.runInTerminal": true, можно вместо true написать false.
// gcc -std=c99 это стандарт его нужно установить
/*Информационное сообщение - такие комментарии были на старых стандартах*/
// так отображаются новые комментарии

// #include <stdio.h> //include это директива препроцессора. все директивы начинаются с символа #. Она означает что нужно включить заголовочный файл в то место где записана директива. в нашем случае включаем stdio.h. Изначально в С вообще ничего нет, и в заголовке stdio.h прописана функция printf. То есть даже для функции принт нужен модуль. Подробнее, реализацию функций добавляет линкер, а в заголовке stdio.h только ее описание. stdio - standart unput output, стандарты ввода и вывода. .h это означает что файл то есть модуль заголовочный. Без этого заголовчного модуля будет не определена функция printf

// int main(void)
// {
//     printf('Hello, World!!! happy new year!!!\n');
//     return 0;
// }

// в С обяз для строк двойные кавычки

// функция это активный элемент программы, которая выполняет заключенные в ней операторы, то есть инструкции. Все программы на языке С это набор функций и их вызов в запрограммированном порядке. Первая функция всегда называется main, с нее начинается запуск кода. Всегда с нее запуск идет.
// при запуске программы ОС передает управление секции кода с переходом по метке _start, потом идут подготовительные действия, потом идет запуск функции main. Потом завершающие действия, потом метка _exit
// Перед функций идет тип int. это означает целочисленный тип данных и что функция main возвращает целочисленное значение. Потом идут скобки и прописаные некие параметры. Мы написали void, это означает пустой. Далее в фигурных скобках идет тело функции, то есть, он выполняется последовательно сверху вниз. После каждой строки ; . В конце идет оператор return, он указывает то, что возвратит функця main. По умолчанию там указывается 0. Это значение передается системному вызову и он завершает нашу программу. 0 означает что программа выполнила свою функцию и успешно завершила свою задачу. Все другие цифры будут означать ошибки при выполнении программы. Например видна выдает ошибку открытия файла за запись. Но в программировании обычно выводят сообщение об ошибке, а код завершения оставляют все равно 0. printf это форматированная строка.
// #4. Двоичная, шестнадцатеричная и восьмеричная системы счисления!!!!!!
// В десятичной системе счисления цифры обозначаются цифрами от 0 до 9
// 7843 = 7 * 10**3 + 8 * 10**2 + 4* 10**1 + 3 * 10 **0
// каждую цифру нужно умножить на 10 в степени разряда, они считаются от 0 справа налево
// Двойная СС
// каждая ячейка памяти состоит из 8 бит.
// Каждый бит может быть в двух состояниях 0 и 1
// Представим что набор из 8 бит организован как счетчик электроэнергии
// 0 0 0 0 0 0 0 0 = 0
// 0 0 0 0 0 0 0 1 = 1 прокрутили правый разряд он стал 1
// 0 0 0 0 0 0 1 0 = 2 еще раз прокрутим правый разряд цифра 1 сдвинется и самая первая цифра станет 0 и тд
// 0 0 0 0 0 0 1 1 = 3
// 0 0 0 0 0 1 0 0 = 4 и так далее перемещаем единицы
// 0 0 0 0 0 1 0 1 = 5
// ....
// 1 1 1 1 1 1 1 1 = 255 всего 255 вариантов, то есть от 0 до 255
// как идет счетичк в двоичной системе: прибавляем единицу в самый правый элемент и если число будет больше единицы, то единицей становится следующий элемент слева
// перевод из двоичной такой же как в десятичной,  каждую цифру умножаем 2 в соответствующей степени разрядности числа
// Что будет если мы прибавим к числу 255 в двоичной системе счисления 1, то есть 255+1. Единица сместится на девятый бит, но его нет в ячейке памяти. Поэтому число превратится в число 0. Этот эффект в програмировании называется переполненеим. Если от нуля отнять 1 то получим снова 255, то есть получается что мы девятый бит обнулили, и опять предыдущая комбинация получилась. 0-1=255. 255+1=0. Эти эффекты переполнеия нужно учитывать при работе с целыми числами. Но в тоже время и такую разность как 0-1 можно интерпретировать как число -1. Если крайнюю правую шестереноку прокрутить еще раз, получится -2. ТО есть 0 -1 -1 = -2. И так далее, будут идти отрицательные числа. Самый старший бит это знаковый бит, то есть 1 отрицательное число, 0 положительное. Получается так:
// 1 0 0 0 0 0 0 0 = -128
// 0 1 1 1 1 1 1 1 = 127
// Такой диапазон значений для 1 байта
// Можно под диапазон целых чисел отвести 2 байта. Это будет от 0 до 2^16-1. ТО есть [0; 2^16-1] = [0; 65535]
// если нужно представить и положительные и отрицательные числа, то это будет от - 32768 до 32767
// это 2 байта
// 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 = -32768
// 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 = 32767
// если этого не будет достаточно, то можно взять 4 байта или 8 байт. Обычно 8 байт достаточно практически для всех задач программирования.
// ДЗ расчитать для 8 байтов и 4 байтов
// шестнадцатиричная СС, 16 ричная СС
// число возможных вариантов составляет 16
// 0 1 2 3 4 5 6 7 8 9 A B C D E F
// Если переводить в двоичную СС, то это будет просто перевод как с десятичной СС, только для букв будет перевод как бы для цифры 10 11 и тд
// Переводить в 16-ричную СС из двоичной очень легко
// Например:
// 1A = 00011010
// B1 = 10110001
// То есть переводим каждый символ 16-ричной СС в двоичную СС, то есть число А 16-ричной СС в 2-чной СС это 1010, а 1 это 0001, получили A1 = 00011010. Число B 16-ричной СС в 2-чной это 1011, а 1 это 0001, получили B1 = 10110001. Таблицу перевода 16-ричной СС в 2-чную есть в гугле. Переводи с помощью умножения такой же как в других СС, только умножаем на 16 в степени разрядности цифры.
// Восмиричная СС
// 0 1 2 3 4 5 6 7
// Перевод с умножением такой же.
// При разработке программ можно работать с 10-й СС. На другие переходить только если это будет удобнее. При компилировании все равно все переводится в двоичный код. Дробные числа представляются на много сложнее и с ними все работает медленее. Использовать дробные числа нужно только при необходимости.

// Переменные и их базовые типы. Модификаторы unsigned и signed!!!!!!!!
#include <stdio.h>
int main(void)
{
    int a = 3, b = 4;
    double res = 0.75;

    printf("||-----|-----|-----|-----||\n");
    printf("|| act | one | two | res ||\n");
    printf("||=====+=====+=====+=====||\n");
    printf("||%5c|%5d|%5d|%5d||\n", '+', a, b, a + b);
    printf("||%5c|%5d|%5d|%5d||\n", '-', a, b, a - b);
    printf("||%5c|%5d|%5d|%5d||\n", '*', a, b, a * b);
    printf("||%-5c|%5d|%5d|%1.3f||\n", '/', a, b, res);
    printf("===========================");

    return (0);
}