/* ранее были только механиеские вычислительные машины на основе двоичного кода
ада лавлейс первый программист. Она написала первые команды для вычислений на ручной механической машине
 была еще машина тьюринга для вычислений, уже электрическая
Потом Джон Фон Нейман предложил хранить команды и данные в единой однородной памяти компьютера, а раньше данные и команды записывали в один тип памяти, а данные в другую. Это было прорывным событием, и сейчас до сих пор вся вычислительная техника работает по архитектуре Джона Фон Неймана.
Первое поколение компов использовали этот принцип на электронных лампах для однородности памяти данных и команд. Вычислительная техника получили название машина Фон Неймана.
Второе поколение компов уже было выполнено на транзисторах. ТО есть просто много транзисторов
Третье поколение было уже на основе интегральных схем, это объединение большого колва транзисторов. Компы стали занимать еще меньше места в помещении.
Четвертое поколение компов это уже появление микропроцессора. То есть очень много маленьких схем, в которых очень маленькие транзисторы, это моя догадка. Компы уже стали доступны массовому пользователю. И сейчас все компы можно отнести в 4 поколению, что-то принципиально нового в компах на данный момент не появилось.
архитектура компа:
процессор взаимодействует с другими частями компа через шину которая присоединяется к контроллерам по отдельности на каждое подсоединенное устройство, другие части компа ОЗУ, монитор, клавиатура, HDD, все присоединяется с помощью контроллеров по отдельному контроллеру для каждого устройства. Это сделано так, потому в процессоре нет инфы как считыывать инфу с других подсоединенных к нему устройств. Процессор может только выдавать определенные данные и считывать их из шины. В шину ЦП передает разную инфу: данные адреса, команды управления. Шина делится на 3 составляющие: шина данных, шина адресов, шина управления. И потом с помощью контроллеров ЦП может взаимодействовать с ними на универсальном уровне. Чтобы процессор знал какие команды подавать существуют специальные программы - драйверы, с помощью процессор знает какие команды подавать на то или иное устройство.
Память.
Память это последовательность упорядоченных ячеек. Каждая ячейка имеет свой физический номер, то есть адрес. А сама ячейка представляет собой 8 бит информации. 1 бит кодируется двумя состояними, 0 и 1. То есть одна ячейка памяти это набор из нулей и единиц. 0 это бит выключен, 1 бит включен. 1 ячейка может кодировать 256 различных вариантов, от нуля до 255, 2**8. Каждая ячейка памяти это 1 байт, в котором можно хранить число от 0 до 255.
ЦП заносит в любую ячейку памяти то или иное значение. Либо осуществляет запрос из любой ячейки памяти.
В такой памяти можно хранить комадны для ЦП и данные. Команды и данные кодируются числами от 0 до 255.
Выполнение команд.
Предположим что в ОЗУ хранится набор числа в 16ричной системе счисления (СС), начнем отсчет с ячейки с номером 1000
Процессор оснащен 32 разрядным процессором архитектуры х86.
Чтобы на вход команды поступило первое число с номером в памяти 1000, счетчик команд в ЦП должен быть равен 1000.
В процессоре есть специальные хранилища данных, которые называются регистрами. В них хранится специальная инфа для обработки текущей инфы. Доступ к регистрам происходит очень быстро. Быстрее чем обращение к оперативной памяти. Один регистров процессора это счетчик команд, program counter: xxxx. Его еще называют указателем инструкций.
В счетчике команд  находится инфа о ячейке памяти, то есть в ячейке есть какая-то цифра и она является адресом памяти. Потом в это число записывается инфа со следующей ячейкой памяти. И так далее для каждой команды. Команду могут быть как цифрами так и знаками сложения и вычитания и тд.
Выглядит команда так: команда movl[адрес памяти],%eax. Это команда на ассемблере. То есть процессор должен переместить по адресу памяти в скобках в спец регистр с названием eax, это один из регистров процессора, потом считываются следующие 4 байта. Каждое перемещение это такт процессора. 1ГГЦ это 1 млрд команд в секунду. Размер порций данных называют машинным словом. Обычно размер машинного слова совпадает с разрядностью процессора. Для 32-разрядного процессора машинное слово 32 бита. Процессор обрабатывает только числовые данные. Например все буквы сохарняются в таблице аскикодов. Изобрадения это набор отдельных точек, пикселей, цвет которых определяется числовым значением. Все данные чтобы перенести на пк, их нужно перенести в набор чисел, то есть оцифровать. А все устройства, принтеры, колонки, они преобразуют инфу в исходный привычный для нас вид, то есть звуки картинки и тд.
Теперь чтобы нам просто написать код, нужно написать сначала структуру взаимодействия между процессором клавиатурой монитром мышью, ЖД и память и всеми остальными устройствами. ЧТобы этого не делать для есть операционная система, в ней установлены все нужны драйверы для всех устройств, и система иногда сама ставит драйверы, но не для всех устройств. Для других устройств клавы, мышки и тд используются драйверы.
Запросы со стороны пользователя называются системными вызовами. Через них происходит взаимодействие со всеми устройставми.система через вызовы также выделяет память под нужные данные. ОС нужна для корректного выполнения ПО на компе и взимодействия с ресурсами вычислительной техники. Например в датацентрах есть много компов без клавы и дисплея. Можно установить взаимодействие через сеть ethernet и через командную строку выполнить нужные действия. В 60-х годах появились первые ОС, они не имели пользовательского интерфеса, и все взаимодействие было на уровне команд. Потом начали появляться графические интерфейсы для пользователей. До середины 90-х они не были массовым явлением среди людей. Пока в 95-м году не вышла ОС windows 95. Она стала очень популярна. Эта ОС популярна и до сих пор, и конечно она уже обновлялась много раз.
Есть и другие типы ОС, такие как unix. К ним относят разные вариации linux: debian, ubuntu, fedora, centos. Есть ОС DBS она не относится linux, это другая ОС. И есть еще MacOS. Графический интерфейс в unix реализован не на уровне ядра системы как в windows, а как пользовательская программа, интерфейс которой можно изменить если нужна другая графиская оболочка. Также открытый код unix позволяет создать свои вариации ОС. Из-за этого появилась первая версия ОС adnroid. Появление unix способствовало появлению первой версии языка C.
Некто кен томпсон делал ОС multics. Разработка была неудачная. Но потом эту ОС улучшили. Назвали ее unix. Потом сделали ОС для компа pdp7. Это очень старый комп. Потом кен томпсон совместно с денисом ритчи решили перенести ее на машину pdp11. Для этого нужно было переписать ОС. ЧТобы не писать на ассемблере Кен томпсон решил использовать язык B, это усеченная версия языка bcpl. Он был очень не удобным для создания ОС. Решили усовершенствовать язык B и назвали его C, это просто след буква алфавита. В 1972 году появилась первая версия языка C. Автором считается денис ритчи. На этом языке C кон томпсон написал ОС unix для пк pdp11. Язык С был создан чтобы уйти от языка ассемблера на более высокий уровень, но при этом сохранить все приемущества языка ассемблер, предоставляя программисту полный контроль и полную свободу действий. То есть С самый низкоуровневый из всех высокоуровневых языков. На нем пишут беспилотники, искуственный интеллект и тд.






















*/
/*Информационное сообщение - такие комментарии были на старых стандартах*/
// так отображаются новые комментарии

#include <stdio.h> //include это директива препроцессора. все директивы начинаются с символа #. Она означает что нужно включить заголовочный файл в то место где записана директива. в нашем случае включаем stdio.h. ИЗначально в С вообще ничего нет, и в заголовке stdio.h прописана функция printf

int main(void)
{
    printf("Hello, World!!! happy new year!!!\n");
    return 0;
}
// gcc -std=c99 это стандарт его нужно установить
// в С обяз для строк двойные кавычки

// как идет счетичк в двоичной системе: прибавляем единицу в самый правый элемент и если число будет больше единицы, то единицей становится следующий элемент слева
